{
  "name": "Bookmark Processor",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "process-bookmark",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -200,
        100
      ],
      "webhookId": "process-bookmark"
    },
    {
      "parameters": {
        "jsCode": "// Extract URL and determine type from webhook\n// Supports: direct API calls, Notion automation webhooks\nconst input = $input.first().json;\nconst body = input.body || input;\n\n// Notion automation sends: { source: {...}, data: { id, properties: { Link: { url } } } }\n// Direct API sends: { url, notion_page_id }\nconst notionData = body.data || {};\nconst props = notionData.properties || body.properties || {};\n\n// Get URL - check multiple possible locations\nconst url = body.url || props.Link?.url || notionData.url || input.url;\n\n// Get Notion page ID - from direct call or Notion automation\nconst notionPageId = body.notion_page_id || notionData.id || body.id || body.page_id || input.notion_page_id;\n\nif (!url) {\n  throw new Error(`No URL provided. Expected 'url' or 'Link' property. Got body keys: ${Object.keys(body).join(', ')}`);\n}\n\n// Video URL patterns\nconst videoPatterns = [\"tiktok.com\", \"youtube.com\", \"youtu.be\", \"vimeo.com\", \"twitch.tv\"];\nconst isVideo = videoPatterns.some(pattern => url.toLowerCase().includes(pattern));\n\n// Extract domain using regex (URL constructor not available in n8n sandbox)\nconst domainMatch = url.match(/^https?:\\/\\/(?:www\\.)?([^\\/:]+)/);\nconst domain = domainMatch ? domainMatch[1] : 'unknown';\n\nreturn {\n  url,\n  notionPageId,\n  domain,\n  isVideo,\n  processorUrl: isVideo \n    ? \"https://us-central1-video-processor-rhe.cloudfunctions.net/video-downloader\"\n    : \"https://us-central1-video-processor-rhe.cloudfunctions.net/webpage-enricher\"\n};"
      },
      "id": "detect-type",
      "name": "Detect URL Type",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        100
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $json.processorUrl }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.isVideo ? JSON.stringify({ video_url: $json.url }) : JSON.stringify({ url: $json.url }) }}",
        "options": {
          "timeout": 600000
        }
      },
      "id": "call-processor",
      "name": "Call Processor",
      "onError": "continueErrorOutput",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        440,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// Get result from processor - handle wrapped data field\nlet rawResult = $input.first().json;\nlet result = rawResult;\n\nif (rawResult.data && typeof rawResult.data === 'string') {\n  result = JSON.parse(rawResult.data);\n}\n\nconst detectData = $('Detect URL Type').item.json;\nconst metadata = result.metadata || {};\nconst geminiAnalysis = result.gemini_analysis || {};\n\n// Helper: Extract summary from Gemini analysis\nfunction extractSummary(analysis) {\n  if (!analysis) return null;\n  \n  const keyMessagesMatch = analysis.match(/(?:Key Messages|Main Points|Takeaways)[:\\s]*([\\s\\S]*?)(?=\\n\\n\\d\\.|\\n\\n\\*\\*|$)/i);\n  if (keyMessagesMatch && keyMessagesMatch[1]) {\n    const cleaned = keyMessagesMatch[1]\n      .replace(/^[:\\s*-]+/gm, '')\n      .replace(/\\*\\*/g, '')\n      .trim()\n      .split('\\n')\n      .filter(line => line.trim())\n      .slice(0, 3)\n      .join('. ')\n      .replace(/^[:\\s]+/, '');\n    return cleaned.substring(0, 500);\n  }\n  \n  const paragraphs = analysis.split('\\n\\n').filter(p => p.length > 50);\n  if (paragraphs.length > 0) {\n    return paragraphs[0].replace(/\\*\\*/g, '').replace(/^[:\\s]+/, '').substring(0, 500);\n  }\n  \n  return analysis.replace(/^[:\\s]+/, '').substring(0, 500);\n}\n\n// Helper: Generate a proper short title (max 70 chars) - NO author in title\nfunction generateTitle(videoTitle, analysis, author) {\n  if (!analysis) {\n    // Fallback to video title if no analysis\n    if (videoTitle && !/^[0-9]+$/.test(videoTitle)) {\n      return videoTitle.replace(/#\\w+/g, '').trim().substring(0, 70);\n    }\n    return 'Untitled Video';\n  }\n  \n  // Extract key topics from analysis\n  let topics = [];\n  \n  // Look for software/tools mentioned\n  const toolsMatch = analysis.match(/(?:using|discusses?|about|explains?)\\s+([A-Z][a-zA-Z]+(?:\\s+(?:Code|AI|Pro|Studio))?(?:\\s+(?:and|vs|or|,)\\s+[A-Z][a-zA-Z]+(?:\\s+(?:Code|AI|Pro|Studio))?)*)/g);\n  if (toolsMatch) {\n    for (const match of toolsMatch) {\n      const tools = match.replace(/^(using|discusses?|about|explains?)\\s+/i, '');\n      if (tools.length > 5 && tools.length < 50) {\n        topics.push(tools);\n      }\n    }\n  }\n  \n  // Look for quoted text or specific topics\n  const quotedMatch = analysis.match(/[\"']([^\"']{10,50})[\"']/g);\n  if (quotedMatch) {\n    for (const q of quotedMatch.slice(0, 2)) {\n      topics.push(q.replace(/[\"']/g, ''));\n    }\n  }\n  \n  // Look for \"how to\" patterns\n  const howToMatch = analysis.match(/how to\\s+([^.\\n]{10,40})/i);\n  if (howToMatch) {\n    topics.push('How to ' + howToMatch[1].trim());\n  }\n  \n  // Look for main subject patterns\n  const subjectPatterns = [\n    /(?:video|content)\\s+(?:is\\s+)?about\\s+([^.\\n]{5,40})/i,\n    /discusses?\\s+(?:the\\s+)?(?:benefits?|use|usage)\\s+of\\s+([^.\\n]{5,40})/i,\n    /explains?\\s+(?:how|why|what)\\s+([^.\\n]{5,40})/i,\n    /tips?\\s+(?:on|for|about)\\s+([^.\\n]{5,40})/i\n  ];\n  \n  for (const pattern of subjectPatterns) {\n    const match = analysis.match(pattern);\n    if (match && match[1]) {\n      topics.push(match[1].replace(/\\*\\*/g, '').trim());\n    }\n  }\n  \n  // Build title from best topic\n  let title = '';\n  \n  if (topics.length > 0) {\n    // Use the first meaningful topic\n    const bestTopic = topics.find(t => t.length >= 10 && t.length <= 60) || topics[0];\n    title = bestTopic.replace(/\\*\\*/g, '').trim();\n    \n    // Capitalize first letter of each word for title case\n    title = title.split(' ').map(word => {\n      if (['and', 'or', 'the', 'a', 'an', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'].includes(word.toLowerCase())) {\n        return word.toLowerCase();\n      }\n      return word.charAt(0).toUpperCase() + word.slice(1);\n    }).join(' ');\n    \n    // Ensure first word is capitalized\n    title = title.charAt(0).toUpperCase() + title.slice(1);\n  }\n  \n  // If no good title found, try video title\n  if (!title || title.length < 10) {\n    if (videoTitle && !/^[0-9]+$/.test(videoTitle)) {\n      title = videoTitle.replace(/#\\w+/g, '').trim();\n    }\n  }\n  \n  // Final cleanup and length check\n  title = title || 'Untitled Video';\n  if (title.length > 70) {\n    title = title.substring(0, 70).trim();\n  }\n  \n  // Remove trailing punctuation except for question marks\n  title = title.replace(/[.,;:]+$/, '');\n  \n  return title;\n}\n\n// Build normalized output\nconst output = {\n  notionPageId: detectData.notionPageId,\n  url: result.url || detectData.url,\n  domain: result.domain || detectData.domain,\n  processed_at: result.processed_at || new Date().toISOString()\n};\n\nif (detectData.isVideo) {\n  output.type = 'video';\n  output.author = metadata.uploader || result.author;\n  output.title = generateTitle(metadata.title, geminiAnalysis.analysis, output.author);\n  output.duration = metadata.duration;\n  output.thumbnail = metadata.thumbnail;\n  output.ai_analysis = geminiAnalysis.analysis;\n  output.ai_summary = extractSummary(geminiAnalysis.analysis);\n  output.video_url = result.video?.public_url;\n  output.audio_url = result.audio?.public_url;\n  output.transcript = (result.transcription && typeof result.transcription === 'object') ? result.transcription.text : result.transcription;\n  output.music = result.music;\n} else {\n  output.type = result.type || 'article';\n  output.author = result.author;\n  output.title = generateTitle(result.title, result.ai_analysis, output.author);\n  output.ai_summary = result.ai_summary || result.description;\n  output.ai_analysis = result.ai_analysis;\n  output.reading_time = result.reading_time;\n  output.price = result.price;\n  output.currency = result.currency;\n  output.code_snippets = result.code_snippets;\n}\n\nif (result.error) {\n  output.error = result.error;\n}\n\nreturn output;"
      },
      "id": "normalize-results",
      "name": "Normalize Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        660,
        0
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-notion-id",
              "leftValue": "={{ $json.notionPageId }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-notion-id",
      "name": "Has Notion Page?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        880,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// Build Notion API update payload\nconst data = $input.first().json;\n\n// Map type to Notion select options\nconst typeMap = {\n  'video': 'Video',\n  'article': 'Article',\n  'product': 'Product',\n  'tool': 'Tool',\n  'code': 'Code',\n  'social': 'Social',\n  'other': 'Other'\n};\n\nconst properties = {};\n\n// Title\nif (data.title) {\n  properties['Title'] = {\n    title: [{ text: { content: data.title.substring(0, 2000) } }]\n  };\n}\n\n// Type (select)\nif (data.type) {\n  properties['Type'] = {\n    select: { name: typeMap[data.type] || 'Other' }\n  };\n}\n\n// AI Summary (rich_text)\nif (data.ai_summary) {\n  properties['AI Summary'] = {\n    rich_text: [{ text: { content: data.ai_summary.substring(0, 2000) } }]\n  };\n}\n\n// Domain (rich_text)\nif (data.domain) {\n  properties['Domain'] = {\n    rich_text: [{ text: { content: data.domain } }]\n  };\n}\n\n// Author (rich_text)\nif (data.author) {\n  properties['Author'] = {\n    rich_text: [{ text: { content: data.author.substring(0, 200) } }]\n  };\n}\n\n// Reading Time (number)\nif (data.reading_time) {\n  properties['Reading Time'] = {\n    number: data.reading_time\n  };\n}\n\n// Price (number)\nif (data.price !== undefined && data.price !== null) {\n  properties['Price'] = {\n    number: data.price\n  };\n}\n\n// Status -> To review (since we just processed it)\nproperties['Status'] = {\n  status: { name: 'To review' }\n};\n\n// Sync Status -> Not Synced (needs Raindrop sync)\nproperties['Sync Status'] = {\n  select: { name: 'Not Synced' }\n};\n\nreturn {\n  pageId: data.notionPageId,\n  properties,\n  originalData: data\n};"
      },
      "id": "build-notion-payload",
      "name": "Build Notion Payload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1100,
        -100
      ]
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "=https://api.notion.com/v1/pages/{{ $json.pageId }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "notionApi",
        "sendHeaders": true,
        "specifyHeaders": "json",
        "jsonHeaders": "{\n  \"Notion-Version\": \"2022-06-28\"\n}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ properties: $json.properties }) }}",
        "options": {}
      },
      "id": "update-notion-page",
      "name": "Update Notion Page",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1320,
        -100
      ],
      "credentials": {
        "notionApi": {
          "id": "vGGxyUaNL70rqYcQ",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://api.notion.com/v1/blocks/{{ $('Build Notion Payload').item.json.pageId }}/children",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "notionApi",
        "sendHeaders": true,
        "specifyHeaders": "json",
        "jsonHeaders": "{\n  \"Notion-Version\": \"2022-06-28\"\n}",
        "options": {}
      },
      "id": "get-page-blocks",
      "name": "Get Page Blocks",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1540,
        -100
      ],
      "credentials": {
        "notionApi": {
          "id": "vGGxyUaNL70rqYcQ",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Delete existing blocks from page body\nconst blocks = $input.first().json.results || [];\nconst pageId = $('Build Notion Payload').item.json.pageId;\n\n// Return block IDs to delete (we'll use SplitInBatches if needed)\nconst blockIds = blocks.map(b => b.id);\n\nreturn { blockIds, pageId, blockCount: blockIds.length };"
      },
      "id": "prepare-delete-blocks",
      "name": "Prepare Delete Blocks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        -100
      ]
    },
    {
      "parameters": {
        "jsCode": "// Build Notion blocks: H2 for AI Analysis, toggles for subsections\nconst payload = $('Build Notion Payload').item.json;\nconst data = payload.originalData;\nconst blocks = [];\n\n// Section icons\nconst sectionIcons = {\n  'Visual Content': 'üëÅÔ∏è',\n  'Audio Content': 'üîä',\n  'Audio': 'üîä',\n  'Style & Production': 'üé¨',\n  'Style': 'üé¨',\n  'Mood & Tone': 'üé≠',\n  'Mood': 'üé≠',\n  'Key Messages': 'üí°',\n  'Content Category': 'üìÅ',\n  'Transcript': 'üìù',\n  'Code Snippets': 'üíª',\n  'Music Recognition': 'üéµ'\n};\n\n// Helper: Parse markdown text to Notion rich_text array\nfunction parseMarkdown(text) {\n  if (!text) return [];\n  \n  const richText = [];\n  const pattern = /(\\*\\*[^*]+\\*\\*|\\*[^*]+\\*|[^*]+)/g;\n  let match;\n  \n  while ((match = pattern.exec(text)) !== null) {\n    let content = match[1];\n    const annotations = { bold: false, italic: false, strikethrough: false, underline: false, code: false, color: 'default' };\n    \n    if (content.startsWith('**') && content.endsWith('**')) {\n      content = content.slice(2, -2);\n      annotations.bold = true;\n    } else if (content.startsWith('*') && content.endsWith('*')) {\n      content = content.slice(1, -1);\n      annotations.italic = true;\n    }\n    \n    if (content.trim()) {\n      richText.push({ type: 'text', text: { content }, annotations });\n    }\n  }\n  \n  return richText.length > 0 ? richText : [{ type: 'text', text: { content: text } }];\n}\n\n// Helper: Parse content into child blocks\nfunction parseContentToBlocks(content) {\n  const children = [];\n  const lines = String(content).split('\\n');\n  let currentParagraph = [];\n  \n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed) {\n      if (currentParagraph.length > 0) {\n        children.push({\n          object: 'block',\n          type: 'paragraph',\n          paragraph: { rich_text: parseMarkdown(currentParagraph.join(' ')) }\n        });\n        currentParagraph = [];\n      }\n      continue;\n    }\n    \n    // Numbered list\n    if (/^\\d+[.)]\\s/.test(trimmed)) {\n      if (currentParagraph.length > 0) {\n        children.push({ object: 'block', type: 'paragraph', paragraph: { rich_text: parseMarkdown(currentParagraph.join(' ')) } });\n        currentParagraph = [];\n      }\n      children.push({\n        object: 'block',\n        type: 'numbered_list_item',\n        numbered_list_item: { rich_text: parseMarkdown(trimmed.replace(/^\\d+[.)]\\s*/, '')) }\n      });\n    }\n    // Bullet list\n    else if (/^[*\\-‚Ä¢]\\s/.test(trimmed)) {\n      if (currentParagraph.length > 0) {\n        children.push({ object: 'block', type: 'paragraph', paragraph: { rich_text: parseMarkdown(currentParagraph.join(' ')) } });\n        currentParagraph = [];\n      }\n      children.push({\n        object: 'block',\n        type: 'bulleted_list_item',\n        bulleted_list_item: { rich_text: parseMarkdown(trimmed.replace(/^[*\\-‚Ä¢]\\s*/, '')) }\n      });\n    }\n    else {\n      currentParagraph.push(trimmed);\n    }\n  }\n  \n  if (currentParagraph.length > 0) {\n    children.push({ object: 'block', type: 'paragraph', paragraph: { rich_text: parseMarkdown(currentParagraph.join(' ')) } });\n  }\n  \n  return children.slice(0, 50);\n}\n\n// Helper: Parse AI analysis into sections\nfunction parseAnalysisSections(analysis) {\n  if (!analysis) return [];\n  \n  const sections = [];\n  const sectionPattern = /\\*\\*([^*]+)\\*\\*[:\\s]*([\\s\\S]*?)(?=\\n\\*\\*|\\n\\d+\\.\\s*\\*\\*|$)/g;\n  let match;\n  \n  while ((match = sectionPattern.exec(analysis)) !== null) {\n    const title = match[1].trim();\n    const content = match[2].trim();\n    if (title && content) {\n      sections.push({ title, content });\n    }\n  }\n  \n  // If no sections found, try numbered format: 1. **Title**\n  if (sections.length === 0) {\n    const numberedPattern = /\\d+\\.\\s*\\*\\*([^*]+)\\*\\*[:\\s]*([\\s\\S]*?)(?=\\n\\d+\\.\\s*\\*\\*|$)/g;\n    while ((match = numberedPattern.exec(analysis)) !== null) {\n      const title = match[1].trim();\n      const content = match[2].trim();\n      if (title && content) {\n        sections.push({ title, content });\n      }\n    }\n  }\n  \n  return sections;\n}\n\n// Add AI Analysis section if present\nif (data.ai_analysis) {\n  // Add H2 heading\n  blocks.push({\n    object: 'block',\n    type: 'heading_2',\n    heading_2: {\n      rich_text: [{ type: 'text', text: { content: 'ü§ñ AI Analysis' } }]\n    }\n  });\n  \n  // Parse into sections and create toggles\n  const sections = parseAnalysisSections(data.ai_analysis);\n  \n  if (sections.length > 0) {\n    for (const section of sections) {\n      const icon = sectionIcons[section.title] || 'üìå';\n      const children = parseContentToBlocks(section.content);\n      \n      if (children.length > 0) {\n        blocks.push({\n          object: 'block',\n          type: 'toggle',\n          toggle: {\n            rich_text: [{ type: 'text', text: { content: `${icon} ${section.title}` } }],\n            children: children\n          }\n        });\n      }\n    }\n  } else {\n    // Fallback: add full analysis as paragraph if can't parse sections\n    blocks.push({\n      object: 'block',\n      type: 'paragraph',\n      paragraph: { rich_text: parseMarkdown(data.ai_analysis.substring(0, 2000)) }\n    });\n  }\n}\n\n// Add Transcript toggle under AI Analysis (not separate section)\nif (data.transcript && typeof data.transcript === 'string' && data.transcript.length > 0) {\n  blocks.push({\n    object: 'block',\n    type: 'toggle',\n    toggle: {\n      rich_text: [{ type: 'text', text: { content: 'üìù Transcript' } }],\n      children: parseContentToBlocks(data.transcript)\n    }\n  });\n}\n\n// Add Code Snippets if present\nif (data.code_snippets && data.code_snippets.length > 0) {\n  blocks.push({\n    object: 'block',\n    type: 'heading_2',\n    heading_2: { rich_text: [{ type: 'text', text: { content: 'üíª Code Snippets' } }] }\n  });\n  \n  const codeChildren = data.code_snippets.slice(0, 5).map(snippet => ({\n    object: 'block',\n    type: 'code',\n    code: {\n      rich_text: [{ type: 'text', text: { content: (snippet.code || snippet).substring(0, 2000) } }],\n      language: (snippet.language || 'plain text').toLowerCase()\n    }\n  }));\n  \n  blocks.push({\n    object: 'block',\n    type: 'toggle',\n    toggle: {\n      rich_text: [{ type: 'text', text: { content: 'üíª View Code' } }],\n      children: codeChildren\n    }\n  });\n}\n\n// Add Music Recognition if present\nif (data.music && data.music.length > 0) {\n  blocks.push({\n    object: 'block',\n    type: 'heading_2',\n    heading_2: { rich_text: [{ type: 'text', text: { content: 'üéµ Music Recognition' } }] }\n  });\n  \n  const musicChildren = data.music.map(track => ({\n    object: 'block',\n    type: 'bulleted_list_item',\n    bulleted_list_item: {\n      rich_text: [{ type: 'text', text: { content: typeof track === 'string' ? track : `${track.title} - ${track.artist}` } }]\n    }\n  }));\n  \n  blocks.push({\n    object: 'block',\n    type: 'toggle',\n    toggle: {\n      rich_text: [{ type: 'text', text: { content: 'üéµ Detected Tracks' } }],\n      children: musicChildren\n    }\n  });\n}\n\nreturn {\n  pageId: payload.pageId,\n  blocks: blocks.slice(0, 95),\n  hasContent: blocks.length > 0,\n  originalData: data\n};"
      },
      "id": "build-page-blocks",
      "name": "Build Page Blocks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1980,
        -100
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-content",
              "leftValue": "={{ $json.hasContent }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "has-page-content",
      "name": "Has Page Content?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2200,
        -100
      ]
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "=https://api.notion.com/v1/blocks/{{ $json.pageId }}/children",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "notionApi",
        "sendHeaders": true,
        "specifyHeaders": "json",
        "jsonHeaders": "{\n  \"Notion-Version\": \"2022-06-28\"\n}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ children: $json.blocks }) }}",
        "options": {}
      },
      "id": "append-page-content",
      "name": "Append Page Content",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2420,
        -200
      ],
      "credentials": {
        "notionApi": {
          "id": "vGGxyUaNL70rqYcQ",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// No content to add, just pass through\nconst data = $('Build Page Blocks').item.json;\nreturn {\n  ...data.originalData,\n  page_content_added: false\n};"
      },
      "id": "skip-page-content",
      "name": "Skip Page Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2420,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// Return original enriched data for response\nconst payload = $('Build Notion Payload').item.json;\nconst pageBlocks = $('Build Page Blocks').item.json;\n\nreturn {\n  ...payload.originalData,\n  notion_updated: true,\n  page_content_added: pageBlocks.hasContent,\n  notion_page_url: `https://notion.so/${payload.pageId.replace(/-/g, '')}`\n};"
      },
      "id": "merge-notion-result",
      "name": "Add Notion Status",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2640,
        -100
      ]
    },
    {
      "parameters": {
        "jsCode": "// No Notion page to update, just pass through\nconst data = $input.first().json;\nreturn {\n  ...data,\n  notion_updated: false\n};"
      },
      "id": "no-notion-update",
      "name": "Skip Notion Update",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1100,
        100
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        2860,
        0
      ]
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "=https://api.notion.com/v1/pages/{{ $('Detect URL Type').item.json.notionPageId }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "notionApi",
        "sendHeaders": true,
        "specifyHeaders": "json",
        "jsonHeaders": "{\n  \"Notion-Version\": \"2022-06-28\"\n}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"properties\": {\n    \"Status\": { \"status\": { \"name\": \"Error\" } }\n  }\n}",
        "options": {}
      },
      "id": "set-error-status",
      "name": "Set Error Status",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        440,
        200
      ],
      "credentials": {
        "notionApi": {
          "id": "vGGxyUaNL70rqYcQ",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "=https://api.notion.com/v1/blocks/{{ $('Detect URL Type').item.json.notionPageId }}/children",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "notionApi",
        "sendHeaders": true,
        "specifyHeaders": "json",
        "jsonHeaders": "{\n  \"Notion-Version\": \"2022-06-28\"\n}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ children: [{ object: 'block', type: 'callout', callout: { rich_text: [{ type: 'text', text: { content: 'Processing failed at ' + new Date().toISOString() + '. Error: ' + ($input.first().json.error?.message || 'Unknown error') } }], icon: { emoji: '‚ùå' }, color: 'red_background' } }] }) }}",
        "options": {}
      },
      "id": "add-error-to-page",
      "name": "Add Error to Page",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        660,
        200
      ],
      "credentials": {
        "notionApi": {
          "id": "vGGxyUaNL70rqYcQ",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "fromEmail": "notifications@royhen.app.n8n.cloud",
        "toEmail": "roy@royengel.com",
        "subject": "=Bookmark Processing Failed: {{ $('Detect URL Type').item.json.url }}",
        "emailType": "text",
        "message": "=Bookmark processing failed.\n\nURL: {{ $('Detect URL Type').item.json.url }}\nDomain: {{ $('Detect URL Type').item.json.domain }}\nNotion Page ID: {{ $('Detect URL Type').item.json.notionPageId }}\n\nError: {{ $input.first().json.error?.message || 'Unknown error' }}\n\nTime: {{ new Date().toISOString() }}",
        "options": {}
      },
      "id": "send-error-email",
      "name": "Send Error Email",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2.1,
      "position": [
        880,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "// Return error response\nconst detectData = $('Detect URL Type').item.json;\nconst error = $input.first().json.error || { message: 'Unknown error' };\n\nreturn {\n  success: false,\n  url: detectData.url,\n  notionPageId: detectData.notionPageId,\n  error: error.message || error,\n  processed_at: new Date().toISOString()\n};"
      },
      "id": "build-error-response",
      "name": "Build Error Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1100,
        200
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 500
        }
      },
      "id": "respond-error",
      "name": "Respond with Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1320,
        200
      ]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Detect URL Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Detect URL Type": {
      "main": [
        [
          {
            "node": "Call Processor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Processor": {
      "main": [
        [
          {
            "node": "Normalize Results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Set Error Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Error Status": {
      "main": [
        [
          {
            "node": "Add Error to Page",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Error to Page": {
      "main": [
        [
          {
            "node": "Send Error Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Error Email": {
      "main": [
        [
          {
            "node": "Build Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Error Response": {
      "main": [
        [
          {
            "node": "Respond with Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Results": {
      "main": [
        [
          {
            "node": "Has Notion Page?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Notion Page?": {
      "main": [
        [
          {
            "node": "Build Notion Payload",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip Notion Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Notion Payload": {
      "main": [
        [
          {
            "node": "Update Notion Page",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Notion Page": {
      "main": [
        [
          {
            "node": "Get Page Blocks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Page Blocks": {
      "main": [
        [
          {
            "node": "Prepare Delete Blocks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Delete Blocks": {
      "main": [
        [
          {
            "node": "Build Page Blocks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Page Blocks": {
      "main": [
        [
          {
            "node": "Has Page Content?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Page Content?": {
      "main": [
        [
          {
            "node": "Append Page Content",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip Page Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Append Page Content": {
      "main": [
        [
          {
            "node": "Add Notion Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Page Content": {
      "main": [
        [
          {
            "node": "Add Notion Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Notion Status": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Notion Update": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  }
}
