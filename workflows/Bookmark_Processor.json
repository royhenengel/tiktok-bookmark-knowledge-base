{
  "updatedAt": "2025-12-30T17:36:45.448Z",
  "createdAt": "2025-12-23T16:31:25.498Z",
  "id": "DJVhLZKH7YIuvGv8",
  "name": "Bookmark Processor",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "process-bookmark",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -200,
        100
      ],
      "webhookId": "process-bookmark"
    },
    {
      "parameters": {
        "jsCode": "// Detect URL Type and set processor endpoint\n// Handle Notion automation webhook structure\nconst input = $input.first().json;\nconst body = input.body || input;\n\n// Extract URL from Notion automation payload\n// Structure: body.data.properties.Link.url\nlet url = '';\nlet notionPageId = null;\n\nif (body.data && body.data.properties) {\n  // Notion automation format\n  url = body.data.properties.Link?.url || '';\n  notionPageId = body.data.id || null;\n} else {\n  // Direct webhook format (fallback)\n  url = body.url || body.URL || '';\n  notionPageId = body.pageId || body.notionPageId || null;\n}\n\n// URL patterns for video vs webpage\nconst videoPatterns = [\"tiktok.com\", \"youtube.com\", \"youtu.be\", \"vimeo.com\", \"twitch.tv\"];\n\n// Determine processor type\nconst isVideo = videoPatterns.some(pattern => url.toLowerCase().includes(pattern));\nconst processorType = isVideo ? 'video' : 'webpage';\n\n// Processor URLs - videos go to Video Processor workflow, webpages to Cloud Function\nconst processors = {\n  video: 'https://royhen.app.n8n.cloud/webhook/analyze-video-complete',\n  webpage: 'https://us-central1-video-processor-rhe.cloudfunctions.net/webpage-enricher'\n};\n\nreturn {\n  url: url,\n  notionPageId: notionPageId,\n  processorType: processorType,\n  processorUrl: processors[processorType],\n  isVideo: isVideo,\n  requestBody: isVideo ? { video_url: url } : { url: url }\n};"
      },
      "id": "detect-type",
      "name": "Detect URL Type",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        100
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $json.processorUrl }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.isVideo ? JSON.stringify({ video_url: $json.url }) : JSON.stringify({ url: $json.url }) }}",
        "options": {
          "timeout": 600000
        }
      },
      "id": "call-processor",
      "name": "Call Processor",
      "onError": "continueErrorOutput",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        440,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// Get result from processor - handle wrapped data field\nlet rawResult = $input.first().json;\nlet result = rawResult;\n\nif (rawResult.data && typeof rawResult.data === 'string') {\n  result = JSON.parse(rawResult.data);\n}\n\nconst detectData = $('Detect URL Type').item.json;\nconst metadata = result.metadata || {};\nconst geminiAnalysis = result.gemini_analysis || {};\n\n// Helper: Extract summary from Gemini analysis\nfunction extractSummary(analysis) {\n  if (!analysis) return null;\n  \n  const keyMessagesMatch = analysis.match(/(?:Key Messages|Main Points|Takeaways)[:\\s]*([\\s\\S]*?)(?=\\n\\n\\d\\.|\\n\\n\\*\\*|$)/i);\n  if (keyMessagesMatch && keyMessagesMatch[1]) {\n    const cleaned = keyMessagesMatch[1]\n      .replace(/^[:\\s*-]+/gm, '')\n      .replace(/\\*\\*/g, '')\n      .trim()\n      .split('\\n')\n      .filter(line => line.trim())\n      .slice(0, 3)\n      .join('. ')\n      .replace(/^[:\\s]+/, '');\n    return cleaned.substring(0, 500);\n  }\n  \n  const paragraphs = analysis.split('\\n\\n').filter(p => p.length > 50);\n  if (paragraphs.length > 0) {\n    return paragraphs[0].replace(/\\*\\*/g, '').replace(/^[:\\s]+/, '').substring(0, 500);\n  }\n  \n  return analysis.replace(/^[:\\s]+/, '').substring(0, 500);\n}\n\n// Helper: Generate a proper short title (max 70 chars) - fallback only\n// Used when generated_metadata.title is not available\nfunction generateTitle(videoTitle, analysis, author) {\n  if (!analysis) {\n    if (videoTitle && !/^[0-9]+$/.test(videoTitle)) {\n      return videoTitle.replace(/#\\w+/g, '').trim().substring(0, 70);\n    }\n    return 'Untitled Video';\n  }\n  \n  let topics = [];\n  \n  const toolsMatch = analysis.match(/(?:using|discusses?|about|explains?)\\s+([A-Z][a-zA-Z]+(?:\\s+(?:Code|AI|Pro|Studio))?(?:\\s+(?:and|vs|or|,)\\s+[A-Z][a-zA-Z]+(?:\\s+(?:Code|AI|Pro|Studio))?)*)/g);\n  if (toolsMatch) {\n    for (const match of toolsMatch) {\n      const tools = match.replace(/^(using|discusses?|about|explains?)\\s+/i, '');\n      if (tools.length > 5 && tools.length < 50) {\n        topics.push(tools);\n      }\n    }\n  }\n  \n  const quotedMatch = analysis.match(/[\\\"']([^\\\"']{10,50})[\\\"']/g);\n  if (quotedMatch) {\n    for (const q of quotedMatch.slice(0, 2)) {\n      topics.push(q.replace(/[\\\"']/g, ''));\n    }\n  }\n  \n  const howToMatch = analysis.match(/how to\\s+([^.\\n]{10,40})/i);\n  if (howToMatch) {\n    topics.push('How to ' + howToMatch[1].trim());\n  }\n  \n  const subjectPatterns = [\n    /(?:video|content)\\s+(?:is\\s+)?about\\s+([^.\\n]{5,40})/i,\n    /discusses?\\s+(?:the\\s+)?(?:benefits?|use|usage)\\s+of\\s+([^.\\n]{5,40})/i,\n    /explains?\\s+(?:how|why|what)\\s+([^.\\n]{5,40})/i,\n    /tips?\\s+(?:on|for|about)\\s+([^.\\n]{5,40})/i\n  ];\n  \n  for (const pattern of subjectPatterns) {\n    const match = analysis.match(pattern);\n    if (match && match[1]) {\n      topics.push(match[1].replace(/\\*\\*/g, '').trim());\n    }\n  }\n  \n  let title = '';\n  \n  if (topics.length > 0) {\n    const bestTopic = topics.find(t => t.length >= 10 && t.length <= 60) || topics[0];\n    title = bestTopic.replace(/\\*\\*/g, '').trim();\n    \n    title = title.split(' ').map(word => {\n      if (['and', 'or', 'the', 'a', 'an', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'].includes(word.toLowerCase())) {\n        return word.toLowerCase();\n      }\n      return word.charAt(0).toUpperCase() + word.slice(1);\n    }).join(' ');\n    \n    title = title.charAt(0).toUpperCase() + title.slice(1);\n  }\n  \n  if (!title || title.length < 10) {\n    if (videoTitle && !/^[0-9]+$/.test(videoTitle)) {\n      title = videoTitle.replace(/#\\w+/g, '').trim();\n    }\n  }\n  \n  title = title || 'Untitled Video';\n  if (title.length > 70) {\n    title = title.substring(0, 70).trim();\n  }\n  \n  title = title.replace(/[.,;:]+$/, '');\n  \n  return title;\n}\n\n// Build normalized output\nconst output = {\n  notionPageId: detectData.notionPageId,\n  url: result.url || detectData.url,\n  domain: result.domain || detectData.domain,\n  processed_at: result.processed_at || new Date().toISOString()\n};\n\nif (detectData.isVideo) {\n  output.type = 'video';\n  output.author = metadata.uploader || result.author;\n  \n  // Use GPT-generated title if available from Video Processor, otherwise fallback\n  if (result.generated_metadata && result.generated_metadata.title) {\n    output.title = result.generated_metadata.title.substring(0, 70);\n  } else {\n    output.title = generateTitle(metadata.title, geminiAnalysis.analysis, output.author);\n  }\n  \n  output.duration = metadata.duration;\n  output.thumbnail = metadata.thumbnail;\n  output.ai_analysis = geminiAnalysis.analysis;\n  output.ai_summary = extractSummary(geminiAnalysis.analysis);\n  output.video_url = result.video?.public_url;\n  output.audio_url = result.audio?.public_url;\n  \n  // Robust transcript extraction - handle all cases\n  let transcript = null;\n  if (result.transcription) {\n    if (typeof result.transcription === 'string') {\n      transcript = result.transcription;\n    } else if (typeof result.transcription === 'object' && result.transcription !== null) {\n      transcript = result.transcription.text || null;\n    }\n  }\n  output.transcript = transcript;\n  output.transcription_raw = result.transcription;\n  \n  // Extract recognized songs array from music object\n  // Build Page Blocks expects an array of {title, artist} objects\n  if (result.music && result.music.recognized_songs && Array.isArray(result.music.recognized_songs)) {\n    output.music = result.music.recognized_songs;\n  } else if (Array.isArray(result.music)) {\n    // Direct array (legacy format)\n    output.music = result.music;\n  } else {\n    output.music = [];\n  }\n} else {\n  output.type = result.type || 'article';\n  output.author = result.author;\n  output.title = generateTitle(result.title, result.ai_analysis, output.author);\n  output.ai_summary = result.ai_summary || result.description;\n  output.ai_analysis = result.ai_analysis;\n  output.reading_time = result.reading_time;\n  output.price = result.price;\n  output.currency = result.currency;\n  output.code_snippets = result.code_snippets;\n  \n  // Add podcast/webpage-specific fields\n  output.description = result.description;\n  output.show_name = result.show_name;\n  output.show_description = result.show_description;\n  output.published_date = result.published_date;\n  output.main_image = result.main_image || result.thumbnail_url;\n  output.duration = result.duration_minutes;\n  \n  // Robust transcript extraction for podcasts\n  let transcript = null;\n  if (result.transcription) {\n    if (typeof result.transcription === 'string') {\n      transcript = result.transcription;\n    } else if (typeof result.transcription === 'object' && result.transcription !== null) {\n      transcript = result.transcription.text || null;\n    }\n  }\n  output.transcript = transcript;\n}\n\nif (result.error) {\n  output.error = result.error;\n}\n\nreturn output;"
      },
      "id": "normalize-results",
      "name": "Normalize Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        660,
        0
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-notion-id",
              "leftValue": "={{ $json.notionPageId }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-notion-id",
      "name": "Has Notion Page?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        880,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// Build Notion API update payload\nconst data = $input.first().json;\n\n// Map type to Notion select options\nconst typeMap = {\n  'video': 'Video',\n  'article': 'Article',\n  'product': 'Product',\n  'tool': 'Tool',\n  'code': 'Code',\n  'social': 'Social',\n  'other': 'Other'\n};\n\nconst properties = {};\n\n// Title\nif (data.title) {\n  properties['Title'] = {\n    title: [{ text: { content: data.title.substring(0, 2000) } }]\n  };\n}\n\n// Type (select)\nif (data.type) {\n  properties['Type'] = {\n    select: { name: typeMap[data.type] || 'Other' }\n  };\n}\n\n// AI Summary (rich_text)\nif (data.ai_summary) {\n  properties['AI Summary'] = {\n    rich_text: [{ text: { content: data.ai_summary.substring(0, 2000) } }]\n  };\n}\n\n// Domain (rich_text)\nif (data.domain) {\n  properties['Domain'] = {\n    rich_text: [{ text: { content: data.domain } }]\n  };\n}\n\n// Author (rich_text)\nif (data.author) {\n  properties['Author'] = {\n    rich_text: [{ text: { content: data.author.substring(0, 200) } }]\n  };\n}\n\n// Reading Time (number)\nif (data.reading_time) {\n  properties['Reading Time'] = {\n    number: data.reading_time\n  };\n}\n\n// Price (number)\nif (data.price !== undefined && data.price !== null) {\n  properties['Price'] = {\n    number: data.price\n  };\n}\n\n// Status -> To review (since we just processed it)\nproperties['Status'] = {\n  status: { name: 'To review' }\n};\n\n// Sync Status -> Not Synced (needs Raindrop sync)\nproperties['Sync Status'] = {\n  select: { name: 'Not Synced' }\n};\n\nreturn {\n  pageId: data.notionPageId,\n  properties,\n  originalData: data\n};"
      },
      "id": "build-notion-payload",
      "name": "Build Notion Payload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1100,
        -100
      ]
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "=https://api.notion.com/v1/pages/{{ $json.pageId }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "notionApi",
        "sendHeaders": true,
        "specifyHeaders": "json",
        "jsonHeaders": "{\n  \"Notion-Version\": \"2022-06-28\"\n}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ properties: $json.properties }) }}",
        "options": {}
      },
      "id": "update-notion-page",
      "name": "Update Notion Page",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1320,
        -100
      ],
      "credentials": {
        "notionApi": {
          "id": "vGGxyUaNL70rqYcQ",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://api.notion.com/v1/blocks/{{ $('Build Notion Payload').item.json.pageId }}/children",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "notionApi",
        "sendHeaders": true,
        "specifyHeaders": "json",
        "jsonHeaders": "{\n  \"Notion-Version\": \"2022-06-28\"\n}",
        "options": {}
      },
      "id": "get-page-blocks",
      "name": "Get Page Blocks",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1540,
        -100
      ],
      "credentials": {
        "notionApi": {
          "id": "vGGxyUaNL70rqYcQ",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Delete existing blocks from page body\nconst blocks = $input.first().json.results || [];\nconst pageId = $('Build Notion Payload').item.json.pageId;\n\n// Return block IDs to delete (we'll use SplitInBatches if needed)\nconst blockIds = blocks.map(b => b.id);\n\nreturn { blockIds, pageId, blockCount: blockIds.length };"
      },
      "id": "prepare-delete-blocks",
      "name": "Prepare Delete Blocks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        -100
      ]
    },
    {
      "parameters": {
        "jsCode": "// Build Notion blocks: H2 for AI Analysis, toggles for subsections\nconst payload = $('Build Notion Payload').item.json;\nconst data = payload.originalData;\nconst blocks = [];\n\n// Notion API limit\nconst MAX_TEXT_LENGTH = 2000;\n\n// Section icons\nconst sectionIcons = {\n  'Visual Content': 'üëÅÔ∏è',\n  'Audio Content': 'üîä',\n  'Audio': 'üîä',\n  'Style & Production': 'üé¨',\n  'Style': 'üé¨',\n  'Mood & Tone': 'üé≠',\n  'Mood': 'üé≠',\n  'Key Messages': 'üí°',\n  'Content Category': 'üìÅ',\n  'Transcript': 'üìù',\n  'Code Snippets': 'üíª',\n  'Music Recognition': 'üéµ'\n};\n\n// Helper: Split text into chunks respecting word boundaries\nfunction splitText(text, maxLength = MAX_TEXT_LENGTH) {\n  if (!text || text.length <= maxLength) return [text];\n  \n  const chunks = [];\n  let remaining = text;\n  \n  while (remaining.length > 0) {\n    if (remaining.length <= maxLength) {\n      chunks.push(remaining);\n      break;\n    }\n    \n    // Find last space before limit\n    let splitAt = remaining.lastIndexOf(' ', maxLength);\n    if (splitAt === -1 || splitAt < maxLength / 2) {\n      // No good space found, force split\n      splitAt = maxLength;\n    }\n    \n    chunks.push(remaining.substring(0, splitAt));\n    remaining = remaining.substring(splitAt).trim();\n  }\n  \n  return chunks;\n}\n\n// Helper: Parse markdown text to Notion rich_text array (with length limit)\nfunction parseMarkdown(text, maxLength = MAX_TEXT_LENGTH) {\n  if (!text) return [];\n  \n  // Truncate if too long for a single rich_text\n  const truncated = text.length > maxLength ? text.substring(0, maxLength) : text;\n  \n  const richText = [];\n  const pattern = /(\\*\\*[^*]+\\*\\*|\\*[^*]+\\*|[^*]+)/g;\n  let match;\n  \n  while ((match = pattern.exec(truncated)) !== null) {\n    let content = match[1];\n    const annotations = { bold: false, italic: false, strikethrough: false, underline: false, code: false, color: 'default' };\n    \n    if (content.startsWith('**') && content.endsWith('**')) {\n      content = content.slice(2, -2);\n      annotations.bold = true;\n    } else if (content.startsWith('*') && content.endsWith('*')) {\n      content = content.slice(1, -1);\n      annotations.italic = true;\n    }\n    \n    if (content.trim()) {\n      richText.push({ type: 'text', text: { content }, annotations });\n    }\n  }\n  \n  return richText.length > 0 ? richText : [{ type: 'text', text: { content: truncated } }];\n}\n\n// Helper: Parse content into child blocks (handles long text)\nfunction parseContentToBlocks(content) {\n  const children = [];\n  const lines = String(content).split('\\n');\n  let currentParagraph = [];\n  \n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed) {\n      if (currentParagraph.length > 0) {\n        const paragraphText = currentParagraph.join(' ');\n        // Split long paragraphs into multiple blocks\n        const chunks = splitText(paragraphText);\n        for (const chunk of chunks) {\n          children.push({\n            object: 'block',\n            type: 'paragraph',\n            paragraph: { rich_text: parseMarkdown(chunk) }\n          });\n        }\n        currentParagraph = [];\n      }\n      continue;\n    }\n    \n    // Numbered list\n    if (/^\\d+[.)]\\s/.test(trimmed)) {\n      if (currentParagraph.length > 0) {\n        const paragraphText = currentParagraph.join(' ');\n        const chunks = splitText(paragraphText);\n        for (const chunk of chunks) {\n          children.push({ object: 'block', type: 'paragraph', paragraph: { rich_text: parseMarkdown(chunk) } });\n        }\n        currentParagraph = [];\n      }\n      const itemText = trimmed.replace(/^\\d+[.)]\\s*/, '');\n      children.push({\n        object: 'block',\n        type: 'numbered_list_item',\n        numbered_list_item: { rich_text: parseMarkdown(itemText.substring(0, MAX_TEXT_LENGTH)) }\n      });\n    }\n    // Bullet list\n    else if (/^[*\\-‚Ä¢]\\s/.test(trimmed)) {\n      if (currentParagraph.length > 0) {\n        const paragraphText = currentParagraph.join(' ');\n        const chunks = splitText(paragraphText);\n        for (const chunk of chunks) {\n          children.push({ object: 'block', type: 'paragraph', paragraph: { rich_text: parseMarkdown(chunk) } });\n        }\n        currentParagraph = [];\n      }\n      const itemText = trimmed.replace(/^[*\\-‚Ä¢]\\s*/, '');\n      children.push({\n        object: 'block',\n        type: 'bulleted_list_item',\n        bulleted_list_item: { rich_text: parseMarkdown(itemText.substring(0, MAX_TEXT_LENGTH)) }\n      });\n    }\n    else {\n      currentParagraph.push(trimmed);\n    }\n  }\n  \n  // Handle remaining paragraph\n  if (currentParagraph.length > 0) {\n    const paragraphText = currentParagraph.join(' ');\n    const chunks = splitText(paragraphText);\n    for (const chunk of chunks) {\n      children.push({ object: 'block', type: 'paragraph', paragraph: { rich_text: parseMarkdown(chunk) } });\n    }\n  }\n  \n  return children.slice(0, 50);\n}\n\n// Helper: Parse AI analysis into sections\nfunction parseAnalysisSections(analysis) {\n  if (!analysis) return [];\n  \n  const sections = [];\n  const sectionPattern = /\\*\\*([^*]+)\\*\\*[:\\s]*([\\s\\S]*?)(?=\\n\\*\\*|\\n\\d+\\.\\s*\\*\\*|$)/g;\n  let match;\n  \n  while ((match = sectionPattern.exec(analysis)) !== null) {\n    const title = match[1].trim();\n    const content = match[2].trim();\n    if (title && content) {\n      sections.push({ title, content });\n    }\n  }\n  \n  // If no sections found, try numbered format: 1. **Title**\n  if (sections.length === 0) {\n    const numberedPattern = /\\d+\\.\\s*\\*\\*([^*]+)\\*\\*[:\\s]*([\\s\\S]*?)(?=\\n\\d+\\.\\s*\\*\\*|$)/g;\n    while ((match = numberedPattern.exec(analysis)) !== null) {\n      const title = match[1].trim();\n      const content = match[2].trim();\n      if (title && content) {\n        sections.push({ title, content });\n      }\n    }\n  }\n  \n  return sections;\n}\n\n// Add AI Analysis section if present\nif (data.ai_analysis) {\n  // Add H2 heading\n  blocks.push({\n    object: 'block',\n    type: 'heading_2',\n    heading_2: {\n      rich_text: [{ type: 'text', text: { content: 'ü§ñ AI Analysis' } }]\n    }\n  });\n  \n  // Parse into sections and create toggles\n  const sections = parseAnalysisSections(data.ai_analysis);\n  \n  if (sections.length > 0) {\n    for (const section of sections) {\n      const icon = sectionIcons[section.title] || 'üìå';\n      const children = parseContentToBlocks(section.content);\n      \n      if (children.length > 0) {\n        blocks.push({\n          object: 'block',\n          type: 'toggle',\n          toggle: {\n            rich_text: [{ type: 'text', text: { content: `${icon} ${section.title}` } }],\n            children: children\n          }\n        });\n      }\n    }\n  } else {\n    // Fallback: add full analysis as paragraph if can't parse sections\n    const chunks = splitText(data.ai_analysis);\n    for (const chunk of chunks) {\n      blocks.push({\n        object: 'block',\n        type: 'paragraph',\n        paragraph: { rich_text: parseMarkdown(chunk) }\n      });\n    }\n  }\n}\n\n// Add Transcript toggle under AI Analysis (not separate section)\nif (data.transcript && typeof data.transcript === 'string' && data.transcript.length > 0) {\n  blocks.push({\n    object: 'block',\n    type: 'toggle',\n    toggle: {\n      rich_text: [{ type: 'text', text: { content: 'üìù Transcript' } }],\n      children: parseContentToBlocks(data.transcript)\n    }\n  });\n}\n\n// Add Code Snippets if present\nif (data.code_snippets && data.code_snippets.length > 0) {\n  blocks.push({\n    object: 'block',\n    type: 'heading_2',\n    heading_2: { rich_text: [{ type: 'text', text: { content: 'üíª Code Snippets' } }] }\n  });\n  \n  const codeChildren = data.code_snippets.slice(0, 5).map(snippet => ({\n    object: 'block',\n    type: 'code',\n    code: {\n      rich_text: [{ type: 'text', text: { content: (snippet.code || snippet).substring(0, MAX_TEXT_LENGTH) } }],\n      language: (snippet.language || 'plain text').toLowerCase()\n    }\n  }));\n  \n  blocks.push({\n    object: 'block',\n    type: 'toggle',\n    toggle: {\n      rich_text: [{ type: 'text', text: { content: 'üíª View Code' } }],\n      children: codeChildren\n    }\n  });\n}\n\n// Add Music Recognition if present\nif (data.music && data.music.length > 0) {\n  blocks.push({\n    object: 'block',\n    type: 'heading_2',\n    heading_2: { rich_text: [{ type: 'text', text: { content: 'üéµ Music Recognition' } }] }\n  });\n  \n  const musicChildren = data.music.map(track => ({\n    object: 'block',\n    type: 'bulleted_list_item',\n    bulleted_list_item: {\n      rich_text: [{ type: 'text', text: { content: typeof track === 'string' ? track : `${track.title} - ${track.artist}` } }]\n    }\n  }));\n  \n  blocks.push({\n    object: 'block',\n    type: 'toggle',\n    toggle: {\n      rich_text: [{ type: 'text', text: { content: 'üéµ Detected Tracks' } }],\n      children: musicChildren\n    }\n  });\n}\n\nreturn {\n  pageId: payload.pageId,\n  blocks: blocks.slice(0, 95),\n  hasContent: blocks.length > 0,\n  originalData: data\n};"
      },
      "id": "build-page-blocks",
      "name": "Build Page Blocks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1980,
        -100
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-content",
              "leftValue": "={{ $json.hasContent }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "has-page-content",
      "name": "Has Page Content?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2200,
        -100
      ]
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "=https://api.notion.com/v1/blocks/{{ $json.pageId }}/children",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "notionApi",
        "sendHeaders": true,
        "specifyHeaders": "json",
        "jsonHeaders": "{\n  \"Notion-Version\": \"2022-06-28\"\n}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ children: $json.blocks }) }}",
        "options": {}
      },
      "id": "append-page-content",
      "name": "Append Page Content",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2420,
        -200
      ],
      "credentials": {
        "notionApi": {
          "id": "vGGxyUaNL70rqYcQ",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// No content to add, just pass through\nconst data = $('Build Page Blocks').item.json;\nreturn {\n  ...data.originalData,\n  page_content_added: false\n};"
      },
      "id": "skip-page-content",
      "name": "Skip Page Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2420,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// Return original enriched data for response\nconst payload = $('Build Notion Payload').item.json;\nconst pageBlocks = $('Build Page Blocks').item.json;\n\nreturn {\n  ...payload.originalData,\n  notion_updated: true,\n  page_content_added: pageBlocks.hasContent,\n  notion_page_url: `https://notion.so/${payload.pageId.replace(/-/g, '')}`\n};"
      },
      "id": "merge-notion-result",
      "name": "Add Notion Status",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2640,
        -100
      ]
    },
    {
      "parameters": {
        "jsCode": "// No Notion page to update, just pass through\nconst data = $input.first().json;\nreturn {\n  ...data,\n  notion_updated: false\n};"
      },
      "id": "no-notion-update",
      "name": "Skip Notion Update",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1100,
        100
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        2860,
        0
      ]
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "=https://api.notion.com/v1/pages/{{ $('Detect URL Type').item.json.notionPageId }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "notionApi",
        "sendHeaders": true,
        "specifyHeaders": "json",
        "jsonHeaders": "{\n  \"Notion-Version\": \"2022-06-28\"\n}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"properties\": {\n    \"Status\": { \"status\": { \"name\": \"Error\" } }\n  }\n}",
        "options": {}
      },
      "id": "set-error-status",
      "name": "Set Error Status",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        440,
        200
      ],
      "credentials": {
        "notionApi": {
          "id": "vGGxyUaNL70rqYcQ",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "=https://api.notion.com/v1/blocks/{{ $('Detect URL Type').item.json.notionPageId }}/children",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "notionApi",
        "sendHeaders": true,
        "specifyHeaders": "json",
        "jsonHeaders": "{\n  \"Notion-Version\": \"2022-06-28\"\n}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ children: [{ object: 'block', type: 'callout', callout: { rich_text: [{ type: 'text', text: { content: 'Processing failed at ' + new Date().toISOString() + '. Error: ' + ($input.first().json.error?.message || 'Unknown error') } }], icon: { emoji: '‚ùå' }, color: 'red_background' } }] }) }}",
        "options": {}
      },
      "id": "add-error-to-page",
      "name": "Add Error to Page",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        660,
        200
      ],
      "credentials": {
        "notionApi": {
          "id": "vGGxyUaNL70rqYcQ",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "fromEmail": "notifications@royhen.app.n8n.cloud",
        "toEmail": "royhenengel@gmail.com",
        "subject": "=Bookmark Processing Failed: {{ $('Detect URL Type').item.json.url }}",
        "emailType": "text",
        "message": "=Bookmark processing failed.\n\nURL: {{ $('Detect URL Type').item.json.url }}\nDomain: {{ $('Detect URL Type').item.json.domain }}\nNotion Page ID: {{ $('Detect URL Type').item.json.notionPageId }}\n\nError: {{ $input.first().json.error?.message || 'Unknown error' }}\n\nTime: {{ new Date().toISOString() }}",
        "options": {
          "senderName": "LifeOS"
        }
      },
      "id": "send-error-email",
      "name": "Send Error Email",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2.1,
      "position": [
        880,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "// Return error response\nconst detectData = $('Detect URL Type').item.json;\nconst error = $input.first().json.error || { message: 'Unknown error' };\n\nreturn {\n  success: false,\n  url: detectData.url,\n  notionPageId: detectData.notionPageId,\n  error: error.message || error,\n  processed_at: new Date().toISOString()\n};"
      },
      "id": "build-error-response",
      "name": "Build Error Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1100,
        200
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 500
        }
      },
      "id": "respond-error",
      "name": "Respond with Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1320,
        200
      ]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Detect URL Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Detect URL Type": {
      "main": [
        [
          {
            "node": "Call Processor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Processor": {
      "main": [
        [
          {
            "node": "Normalize Results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Set Error Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Error Status": {
      "main": [
        [
          {
            "node": "Add Error to Page",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Error to Page": {
      "main": [
        [
          {
            "node": "Send Error Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Error Email": {
      "main": [
        [
          {
            "node": "Build Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Error Response": {
      "main": [
        [
          {
            "node": "Respond with Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Results": {
      "main": [
        [
          {
            "node": "Has Notion Page?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Notion Page?": {
      "main": [
        [
          {
            "node": "Build Notion Payload",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip Notion Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Notion Payload": {
      "main": [
        [
          {
            "node": "Update Notion Page",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Notion Page": {
      "main": [
        [
          {
            "node": "Get Page Blocks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Page Blocks": {
      "main": [
        [
          {
            "node": "Prepare Delete Blocks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Delete Blocks": {
      "main": [
        [
          {
            "node": "Build Page Blocks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Page Blocks": {
      "main": [
        [
          {
            "node": "Has Page Content?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Page Content?": {
      "main": [
        [
          {
            "node": "Append Page Content",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip Page Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Append Page Content": {
      "main": [
        [
          {
            "node": "Add Notion Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Page Content": {
      "main": [
        [
          {
            "node": "Add Notion Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Notion Update": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Notion Status": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": {
    "node:New Bookmark in Notion": {
      "lastTimeChecked": "2025-12-23T17:36:00.000Z",
      "possibleDuplicates": [
        "2d24df89-4a69-80dd-9779-ee7901dd1cfe",
        "2d24df89-4a69-8085-b30f-cea57ad43eb0"
      ]
    }
  },
  "meta": null,
  "pinData": {},
  "versionId": "49662d88-1119-4005-9538-8a9bfa1a610b",
  "activeVersionId": "49662d88-1119-4005-9538-8a9bfa1a610b",
  "versionCounter": 75,
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2025-12-23T16:31:25.501Z",
      "createdAt": "2025-12-23T16:31:25.501Z",
      "role": "workflow:owner",
      "workflowId": "DJVhLZKH7YIuvGv8",
      "projectId": "WLfVoGEbhM21aKQc",
      "project": {
        "updatedAt": "2025-08-06T04:23:31.392Z",
        "createdAt": "2025-08-06T04:23:26.059Z",
        "id": "WLfVoGEbhM21aKQc",
        "name": "Roy Hen Engel <royhenengel@gmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "projectRelations": [
          {
            "updatedAt": "2025-08-06T04:23:26.060Z",
            "createdAt": "2025-08-06T04:23:26.060Z",
            "userId": "cc527931-acd6-4a2e-a333-4c92a84e898d",
            "projectId": "WLfVoGEbhM21aKQc",
            "user": {
              "updatedAt": "2025-12-30T13:26:27.000Z",
              "createdAt": "2025-08-06T04:23:24.660Z",
              "id": "cc527931-acd6-4a2e-a333-4c92a84e898d",
              "email": "royhenengel@gmail.com",
              "firstName": "Roy",
              "lastName": "Hen Engel",
              "personalizationAnswers": null,
              "settings": {
                "userActivated": true,
                "easyAIWorkflowOnboarded": true,
                "firstSuccessfulWorkflowId": "AbZxkqnDDoKqTpAp",
                "userActivatedAt": 1754984654331,
                "npsSurvey": {
                  "responded": true,
                  "lastShownAt": 1766868442844
                }
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2025-12-29",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [],
  "activeVersion": {
    "updatedAt": "2025-12-30T17:36:45.451Z",
    "createdAt": "2025-12-30T17:36:45.451Z",
    "versionId": "49662d88-1119-4005-9538-8a9bfa1a610b",
    "workflowId": "DJVhLZKH7YIuvGv8",
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "process-bookmark",
          "responseMode": "responseNode",
          "options": {}
        },
        "id": "webhook-trigger",
        "name": "Webhook",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          -200,
          100
        ],
        "webhookId": "process-bookmark"
      },
      {
        "parameters": {
          "jsCode": "// Detect URL Type and set processor endpoint\n// Handle Notion automation webhook structure\nconst input = $input.first().json;\nconst body = input.body || input;\n\n// Extract URL from Notion automation payload\n// Structure: body.data.properties.Link.url\nlet url = '';\nlet notionPageId = null;\n\nif (body.data && body.data.properties) {\n  // Notion automation format\n  url = body.data.properties.Link?.url || '';\n  notionPageId = body.data.id || null;\n} else {\n  // Direct webhook format (fallback)\n  url = body.url || body.URL || '';\n  notionPageId = body.pageId || body.notionPageId || null;\n}\n\n// URL patterns for video vs webpage\nconst videoPatterns = [\"tiktok.com\", \"youtube.com\", \"youtu.be\", \"vimeo.com\", \"twitch.tv\"];\n\n// Determine processor type\nconst isVideo = videoPatterns.some(pattern => url.toLowerCase().includes(pattern));\nconst processorType = isVideo ? 'video' : 'webpage';\n\n// Processor URLs - videos go to Video Processor workflow, webpages to Cloud Function\nconst processors = {\n  video: 'https://royhen.app.n8n.cloud/webhook/analyze-video-complete',\n  webpage: 'https://us-central1-video-processor-rhe.cloudfunctions.net/webpage-enricher'\n};\n\nreturn {\n  url: url,\n  notionPageId: notionPageId,\n  processorType: processorType,\n  processorUrl: processors[processorType],\n  isVideo: isVideo,\n  requestBody: isVideo ? { video_url: url } : { url: url }\n};"
        },
        "id": "detect-type",
        "name": "Detect URL Type",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          0,
          100
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $json.processorUrl }}",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ $json.isVideo ? JSON.stringify({ video_url: $json.url }) : JSON.stringify({ url: $json.url }) }}",
          "options": {
            "timeout": 600000
          }
        },
        "id": "call-processor",
        "name": "Call Processor",
        "onError": "continueErrorOutput",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          440,
          0
        ]
      },
      {
        "parameters": {
          "jsCode": "// Get result from processor - handle wrapped data field\nlet rawResult = $input.first().json;\nlet result = rawResult;\n\nif (rawResult.data && typeof rawResult.data === 'string') {\n  result = JSON.parse(rawResult.data);\n}\n\nconst detectData = $('Detect URL Type').item.json;\nconst metadata = result.metadata || {};\nconst geminiAnalysis = result.gemini_analysis || {};\n\n// Helper: Extract summary from Gemini analysis\nfunction extractSummary(analysis) {\n  if (!analysis) return null;\n  \n  const keyMessagesMatch = analysis.match(/(?:Key Messages|Main Points|Takeaways)[:\\s]*([\\s\\S]*?)(?=\\n\\n\\d\\.|\\n\\n\\*\\*|$)/i);\n  if (keyMessagesMatch && keyMessagesMatch[1]) {\n    const cleaned = keyMessagesMatch[1]\n      .replace(/^[:\\s*-]+/gm, '')\n      .replace(/\\*\\*/g, '')\n      .trim()\n      .split('\\n')\n      .filter(line => line.trim())\n      .slice(0, 3)\n      .join('. ')\n      .replace(/^[:\\s]+/, '');\n    return cleaned.substring(0, 500);\n  }\n  \n  const paragraphs = analysis.split('\\n\\n').filter(p => p.length > 50);\n  if (paragraphs.length > 0) {\n    return paragraphs[0].replace(/\\*\\*/g, '').replace(/^[:\\s]+/, '').substring(0, 500);\n  }\n  \n  return analysis.replace(/^[:\\s]+/, '').substring(0, 500);\n}\n\n// Helper: Generate a proper short title (max 70 chars) - fallback only\n// Used when generated_metadata.title is not available\nfunction generateTitle(videoTitle, analysis, author) {\n  if (!analysis) {\n    if (videoTitle && !/^[0-9]+$/.test(videoTitle)) {\n      return videoTitle.replace(/#\\w+/g, '').trim().substring(0, 70);\n    }\n    return 'Untitled Video';\n  }\n  \n  let topics = [];\n  \n  const toolsMatch = analysis.match(/(?:using|discusses?|about|explains?)\\s+([A-Z][a-zA-Z]+(?:\\s+(?:Code|AI|Pro|Studio))?(?:\\s+(?:and|vs|or|,)\\s+[A-Z][a-zA-Z]+(?:\\s+(?:Code|AI|Pro|Studio))?)*)/g);\n  if (toolsMatch) {\n    for (const match of toolsMatch) {\n      const tools = match.replace(/^(using|discusses?|about|explains?)\\s+/i, '');\n      if (tools.length > 5 && tools.length < 50) {\n        topics.push(tools);\n      }\n    }\n  }\n  \n  const quotedMatch = analysis.match(/[\\\"']([^\\\"']{10,50})[\\\"']/g);\n  if (quotedMatch) {\n    for (const q of quotedMatch.slice(0, 2)) {\n      topics.push(q.replace(/[\\\"']/g, ''));\n    }\n  }\n  \n  const howToMatch = analysis.match(/how to\\s+([^.\\n]{10,40})/i);\n  if (howToMatch) {\n    topics.push('How to ' + howToMatch[1].trim());\n  }\n  \n  const subjectPatterns = [\n    /(?:video|content)\\s+(?:is\\s+)?about\\s+([^.\\n]{5,40})/i,\n    /discusses?\\s+(?:the\\s+)?(?:benefits?|use|usage)\\s+of\\s+([^.\\n]{5,40})/i,\n    /explains?\\s+(?:how|why|what)\\s+([^.\\n]{5,40})/i,\n    /tips?\\s+(?:on|for|about)\\s+([^.\\n]{5,40})/i\n  ];\n  \n  for (const pattern of subjectPatterns) {\n    const match = analysis.match(pattern);\n    if (match && match[1]) {\n      topics.push(match[1].replace(/\\*\\*/g, '').trim());\n    }\n  }\n  \n  let title = '';\n  \n  if (topics.length > 0) {\n    const bestTopic = topics.find(t => t.length >= 10 && t.length <= 60) || topics[0];\n    title = bestTopic.replace(/\\*\\*/g, '').trim();\n    \n    title = title.split(' ').map(word => {\n      if (['and', 'or', 'the', 'a', 'an', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'].includes(word.toLowerCase())) {\n        return word.toLowerCase();\n      }\n      return word.charAt(0).toUpperCase() + word.slice(1);\n    }).join(' ');\n    \n    title = title.charAt(0).toUpperCase() + title.slice(1);\n  }\n  \n  if (!title || title.length < 10) {\n    if (videoTitle && !/^[0-9]+$/.test(videoTitle)) {\n      title = videoTitle.replace(/#\\w+/g, '').trim();\n    }\n  }\n  \n  title = title || 'Untitled Video';\n  if (title.length > 70) {\n    title = title.substring(0, 70).trim();\n  }\n  \n  title = title.replace(/[.,;:]+$/, '');\n  \n  return title;\n}\n\n// Build normalized output\nconst output = {\n  notionPageId: detectData.notionPageId,\n  url: result.url || detectData.url,\n  domain: result.domain || detectData.domain,\n  processed_at: result.processed_at || new Date().toISOString()\n};\n\nif (detectData.isVideo) {\n  output.type = 'video';\n  output.author = metadata.uploader || result.author;\n  \n  // Use GPT-generated title if available from Video Processor, otherwise fallback\n  if (result.generated_metadata && result.generated_metadata.title) {\n    output.title = result.generated_metadata.title.substring(0, 70);\n  } else {\n    output.title = generateTitle(metadata.title, geminiAnalysis.analysis, output.author);\n  }\n  \n  output.duration = metadata.duration;\n  output.thumbnail = metadata.thumbnail;\n  output.ai_analysis = geminiAnalysis.analysis;\n  output.ai_summary = extractSummary(geminiAnalysis.analysis);\n  output.video_url = result.video?.public_url;\n  output.audio_url = result.audio?.public_url;\n  \n  // Robust transcript extraction - handle all cases\n  let transcript = null;\n  if (result.transcription) {\n    if (typeof result.transcription === 'string') {\n      transcript = result.transcription;\n    } else if (typeof result.transcription === 'object' && result.transcription !== null) {\n      transcript = result.transcription.text || null;\n    }\n  }\n  output.transcript = transcript;\n  output.transcription_raw = result.transcription;\n  \n  // Extract recognized songs array from music object\n  // Build Page Blocks expects an array of {title, artist} objects\n  if (result.music && result.music.recognized_songs && Array.isArray(result.music.recognized_songs)) {\n    output.music = result.music.recognized_songs;\n  } else if (Array.isArray(result.music)) {\n    // Direct array (legacy format)\n    output.music = result.music;\n  } else {\n    output.music = [];\n  }\n} else {\n  output.type = result.type || 'article';\n  output.author = result.author;\n  output.title = generateTitle(result.title, result.ai_analysis, output.author);\n  output.ai_summary = result.ai_summary || result.description;\n  output.ai_analysis = result.ai_analysis;\n  output.reading_time = result.reading_time;\n  output.price = result.price;\n  output.currency = result.currency;\n  output.code_snippets = result.code_snippets;\n  \n  // Add podcast/webpage-specific fields\n  output.description = result.description;\n  output.show_name = result.show_name;\n  output.show_description = result.show_description;\n  output.published_date = result.published_date;\n  output.main_image = result.main_image || result.thumbnail_url;\n  output.duration = result.duration_minutes;\n  \n  // Robust transcript extraction for podcasts\n  let transcript = null;\n  if (result.transcription) {\n    if (typeof result.transcription === 'string') {\n      transcript = result.transcription;\n    } else if (typeof result.transcription === 'object' && result.transcription !== null) {\n      transcript = result.transcription.text || null;\n    }\n  }\n  output.transcript = transcript;\n}\n\nif (result.error) {\n  output.error = result.error;\n}\n\nreturn output;"
        },
        "id": "normalize-results",
        "name": "Normalize Results",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          660,
          0
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict"
            },
            "conditions": [
              {
                "id": "has-notion-id",
                "leftValue": "={{ $json.notionPageId }}",
                "rightValue": "",
                "operator": {
                  "type": "string",
                  "operation": "notEmpty"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "check-notion-id",
        "name": "Has Notion Page?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          880,
          0
        ]
      },
      {
        "parameters": {
          "jsCode": "// Build Notion API update payload\nconst data = $input.first().json;\n\n// Map type to Notion select options\nconst typeMap = {\n  'video': 'Video',\n  'article': 'Article',\n  'product': 'Product',\n  'tool': 'Tool',\n  'code': 'Code',\n  'social': 'Social',\n  'other': 'Other'\n};\n\nconst properties = {};\n\n// Title\nif (data.title) {\n  properties['Title'] = {\n    title: [{ text: { content: data.title.substring(0, 2000) } }]\n  };\n}\n\n// Type (select)\nif (data.type) {\n  properties['Type'] = {\n    select: { name: typeMap[data.type] || 'Other' }\n  };\n}\n\n// AI Summary (rich_text)\nif (data.ai_summary) {\n  properties['AI Summary'] = {\n    rich_text: [{ text: { content: data.ai_summary.substring(0, 2000) } }]\n  };\n}\n\n// Domain (rich_text)\nif (data.domain) {\n  properties['Domain'] = {\n    rich_text: [{ text: { content: data.domain } }]\n  };\n}\n\n// Author (rich_text)\nif (data.author) {\n  properties['Author'] = {\n    rich_text: [{ text: { content: data.author.substring(0, 200) } }]\n  };\n}\n\n// Reading Time (number)\nif (data.reading_time) {\n  properties['Reading Time'] = {\n    number: data.reading_time\n  };\n}\n\n// Price (number)\nif (data.price !== undefined && data.price !== null) {\n  properties['Price'] = {\n    number: data.price\n  };\n}\n\n// Status -> To review (since we just processed it)\nproperties['Status'] = {\n  status: { name: 'To review' }\n};\n\n// Sync Status -> Not Synced (needs Raindrop sync)\nproperties['Sync Status'] = {\n  select: { name: 'Not Synced' }\n};\n\nreturn {\n  pageId: data.notionPageId,\n  properties,\n  originalData: data\n};"
        },
        "id": "build-notion-payload",
        "name": "Build Notion Payload",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1100,
          -100
        ]
      },
      {
        "parameters": {
          "method": "PATCH",
          "url": "=https://api.notion.com/v1/pages/{{ $json.pageId }}",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "notionApi",
          "sendHeaders": true,
          "specifyHeaders": "json",
          "jsonHeaders": "{\n  \"Notion-Version\": \"2022-06-28\"\n}",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ properties: $json.properties }) }}",
          "options": {}
        },
        "id": "update-notion-page",
        "name": "Update Notion Page",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          1320,
          -100
        ],
        "credentials": {
          "notionApi": {
            "id": "vGGxyUaNL70rqYcQ",
            "name": "Notion account"
          }
        }
      },
      {
        "parameters": {
          "method": "GET",
          "url": "=https://api.notion.com/v1/blocks/{{ $('Build Notion Payload').item.json.pageId }}/children",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "notionApi",
          "sendHeaders": true,
          "specifyHeaders": "json",
          "jsonHeaders": "{\n  \"Notion-Version\": \"2022-06-28\"\n}",
          "options": {}
        },
        "id": "get-page-blocks",
        "name": "Get Page Blocks",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          1540,
          -100
        ],
        "credentials": {
          "notionApi": {
            "id": "vGGxyUaNL70rqYcQ",
            "name": "Notion account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Delete existing blocks from page body\nconst blocks = $input.first().json.results || [];\nconst pageId = $('Build Notion Payload').item.json.pageId;\n\n// Return block IDs to delete (we'll use SplitInBatches if needed)\nconst blockIds = blocks.map(b => b.id);\n\nreturn { blockIds, pageId, blockCount: blockIds.length };"
        },
        "id": "prepare-delete-blocks",
        "name": "Prepare Delete Blocks",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1760,
          -100
        ]
      },
      {
        "parameters": {
          "jsCode": "// Build Notion blocks: H2 for AI Analysis, toggles for subsections\nconst payload = $('Build Notion Payload').item.json;\nconst data = payload.originalData;\nconst blocks = [];\n\n// Notion API limit\nconst MAX_TEXT_LENGTH = 2000;\n\n// Section icons\nconst sectionIcons = {\n  'Visual Content': 'üëÅÔ∏è',\n  'Audio Content': 'üîä',\n  'Audio': 'üîä',\n  'Style & Production': 'üé¨',\n  'Style': 'üé¨',\n  'Mood & Tone': 'üé≠',\n  'Mood': 'üé≠',\n  'Key Messages': 'üí°',\n  'Content Category': 'üìÅ',\n  'Transcript': 'üìù',\n  'Code Snippets': 'üíª',\n  'Music Recognition': 'üéµ'\n};\n\n// Helper: Split text into chunks respecting word boundaries\nfunction splitText(text, maxLength = MAX_TEXT_LENGTH) {\n  if (!text || text.length <= maxLength) return [text];\n  \n  const chunks = [];\n  let remaining = text;\n  \n  while (remaining.length > 0) {\n    if (remaining.length <= maxLength) {\n      chunks.push(remaining);\n      break;\n    }\n    \n    // Find last space before limit\n    let splitAt = remaining.lastIndexOf(' ', maxLength);\n    if (splitAt === -1 || splitAt < maxLength / 2) {\n      // No good space found, force split\n      splitAt = maxLength;\n    }\n    \n    chunks.push(remaining.substring(0, splitAt));\n    remaining = remaining.substring(splitAt).trim();\n  }\n  \n  return chunks;\n}\n\n// Helper: Parse markdown text to Notion rich_text array (with length limit)\nfunction parseMarkdown(text, maxLength = MAX_TEXT_LENGTH) {\n  if (!text) return [];\n  \n  // Truncate if too long for a single rich_text\n  const truncated = text.length > maxLength ? text.substring(0, maxLength) : text;\n  \n  const richText = [];\n  const pattern = /(\\*\\*[^*]+\\*\\*|\\*[^*]+\\*|[^*]+)/g;\n  let match;\n  \n  while ((match = pattern.exec(truncated)) !== null) {\n    let content = match[1];\n    const annotations = { bold: false, italic: false, strikethrough: false, underline: false, code: false, color: 'default' };\n    \n    if (content.startsWith('**') && content.endsWith('**')) {\n      content = content.slice(2, -2);\n      annotations.bold = true;\n    } else if (content.startsWith('*') && content.endsWith('*')) {\n      content = content.slice(1, -1);\n      annotations.italic = true;\n    }\n    \n    if (content.trim()) {\n      richText.push({ type: 'text', text: { content }, annotations });\n    }\n  }\n  \n  return richText.length > 0 ? richText : [{ type: 'text', text: { content: truncated } }];\n}\n\n// Helper: Parse content into child blocks (handles long text)\nfunction parseContentToBlocks(content) {\n  const children = [];\n  const lines = String(content).split('\\n');\n  let currentParagraph = [];\n  \n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed) {\n      if (currentParagraph.length > 0) {\n        const paragraphText = currentParagraph.join(' ');\n        // Split long paragraphs into multiple blocks\n        const chunks = splitText(paragraphText);\n        for (const chunk of chunks) {\n          children.push({\n            object: 'block',\n            type: 'paragraph',\n            paragraph: { rich_text: parseMarkdown(chunk) }\n          });\n        }\n        currentParagraph = [];\n      }\n      continue;\n    }\n    \n    // Numbered list\n    if (/^\\d+[.)]\\s/.test(trimmed)) {\n      if (currentParagraph.length > 0) {\n        const paragraphText = currentParagraph.join(' ');\n        const chunks = splitText(paragraphText);\n        for (const chunk of chunks) {\n          children.push({ object: 'block', type: 'paragraph', paragraph: { rich_text: parseMarkdown(chunk) } });\n        }\n        currentParagraph = [];\n      }\n      const itemText = trimmed.replace(/^\\d+[.)]\\s*/, '');\n      children.push({\n        object: 'block',\n        type: 'numbered_list_item',\n        numbered_list_item: { rich_text: parseMarkdown(itemText.substring(0, MAX_TEXT_LENGTH)) }\n      });\n    }\n    // Bullet list\n    else if (/^[*\\-‚Ä¢]\\s/.test(trimmed)) {\n      if (currentParagraph.length > 0) {\n        const paragraphText = currentParagraph.join(' ');\n        const chunks = splitText(paragraphText);\n        for (const chunk of chunks) {\n          children.push({ object: 'block', type: 'paragraph', paragraph: { rich_text: parseMarkdown(chunk) } });\n        }\n        currentParagraph = [];\n      }\n      const itemText = trimmed.replace(/^[*\\-‚Ä¢]\\s*/, '');\n      children.push({\n        object: 'block',\n        type: 'bulleted_list_item',\n        bulleted_list_item: { rich_text: parseMarkdown(itemText.substring(0, MAX_TEXT_LENGTH)) }\n      });\n    }\n    else {\n      currentParagraph.push(trimmed);\n    }\n  }\n  \n  // Handle remaining paragraph\n  if (currentParagraph.length > 0) {\n    const paragraphText = currentParagraph.join(' ');\n    const chunks = splitText(paragraphText);\n    for (const chunk of chunks) {\n      children.push({ object: 'block', type: 'paragraph', paragraph: { rich_text: parseMarkdown(chunk) } });\n    }\n  }\n  \n  return children.slice(0, 50);\n}\n\n// Helper: Parse AI analysis into sections\nfunction parseAnalysisSections(analysis) {\n  if (!analysis) return [];\n  \n  const sections = [];\n  const sectionPattern = /\\*\\*([^*]+)\\*\\*[:\\s]*([\\s\\S]*?)(?=\\n\\*\\*|\\n\\d+\\.\\s*\\*\\*|$)/g;\n  let match;\n  \n  while ((match = sectionPattern.exec(analysis)) !== null) {\n    const title = match[1].trim();\n    const content = match[2].trim();\n    if (title && content) {\n      sections.push({ title, content });\n    }\n  }\n  \n  // If no sections found, try numbered format: 1. **Title**\n  if (sections.length === 0) {\n    const numberedPattern = /\\d+\\.\\s*\\*\\*([^*]+)\\*\\*[:\\s]*([\\s\\S]*?)(?=\\n\\d+\\.\\s*\\*\\*|$)/g;\n    while ((match = numberedPattern.exec(analysis)) !== null) {\n      const title = match[1].trim();\n      const content = match[2].trim();\n      if (title && content) {\n        sections.push({ title, content });\n      }\n    }\n  }\n  \n  return sections;\n}\n\n// Add AI Analysis section if present\nif (data.ai_analysis) {\n  // Add H2 heading\n  blocks.push({\n    object: 'block',\n    type: 'heading_2',\n    heading_2: {\n      rich_text: [{ type: 'text', text: { content: 'ü§ñ AI Analysis' } }]\n    }\n  });\n  \n  // Parse into sections and create toggles\n  const sections = parseAnalysisSections(data.ai_analysis);\n  \n  if (sections.length > 0) {\n    for (const section of sections) {\n      const icon = sectionIcons[section.title] || 'üìå';\n      const children = parseContentToBlocks(section.content);\n      \n      if (children.length > 0) {\n        blocks.push({\n          object: 'block',\n          type: 'toggle',\n          toggle: {\n            rich_text: [{ type: 'text', text: { content: `${icon} ${section.title}` } }],\n            children: children\n          }\n        });\n      }\n    }\n  } else {\n    // Fallback: add full analysis as paragraph if can't parse sections\n    const chunks = splitText(data.ai_analysis);\n    for (const chunk of chunks) {\n      blocks.push({\n        object: 'block',\n        type: 'paragraph',\n        paragraph: { rich_text: parseMarkdown(chunk) }\n      });\n    }\n  }\n}\n\n// Add Transcript toggle under AI Analysis (not separate section)\nif (data.transcript && typeof data.transcript === 'string' && data.transcript.length > 0) {\n  blocks.push({\n    object: 'block',\n    type: 'toggle',\n    toggle: {\n      rich_text: [{ type: 'text', text: { content: 'üìù Transcript' } }],\n      children: parseContentToBlocks(data.transcript)\n    }\n  });\n}\n\n// Add Code Snippets if present\nif (data.code_snippets && data.code_snippets.length > 0) {\n  blocks.push({\n    object: 'block',\n    type: 'heading_2',\n    heading_2: { rich_text: [{ type: 'text', text: { content: 'üíª Code Snippets' } }] }\n  });\n  \n  const codeChildren = data.code_snippets.slice(0, 5).map(snippet => ({\n    object: 'block',\n    type: 'code',\n    code: {\n      rich_text: [{ type: 'text', text: { content: (snippet.code || snippet).substring(0, MAX_TEXT_LENGTH) } }],\n      language: (snippet.language || 'plain text').toLowerCase()\n    }\n  }));\n  \n  blocks.push({\n    object: 'block',\n    type: 'toggle',\n    toggle: {\n      rich_text: [{ type: 'text', text: { content: 'üíª View Code' } }],\n      children: codeChildren\n    }\n  });\n}\n\n// Add Music Recognition if present\nif (data.music && data.music.length > 0) {\n  blocks.push({\n    object: 'block',\n    type: 'heading_2',\n    heading_2: { rich_text: [{ type: 'text', text: { content: 'üéµ Music Recognition' } }] }\n  });\n  \n  const musicChildren = data.music.map(track => ({\n    object: 'block',\n    type: 'bulleted_list_item',\n    bulleted_list_item: {\n      rich_text: [{ type: 'text', text: { content: typeof track === 'string' ? track : `${track.title} - ${track.artist}` } }]\n    }\n  }));\n  \n  blocks.push({\n    object: 'block',\n    type: 'toggle',\n    toggle: {\n      rich_text: [{ type: 'text', text: { content: 'üéµ Detected Tracks' } }],\n      children: musicChildren\n    }\n  });\n}\n\nreturn {\n  pageId: payload.pageId,\n  blocks: blocks.slice(0, 95),\n  hasContent: blocks.length > 0,\n  originalData: data\n};"
        },
        "id": "build-page-blocks",
        "name": "Build Page Blocks",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1980,
          -100
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict"
            },
            "conditions": [
              {
                "id": "has-content",
                "leftValue": "={{ $json.hasContent }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "has-page-content",
        "name": "Has Page Content?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          2200,
          -100
        ]
      },
      {
        "parameters": {
          "method": "PATCH",
          "url": "=https://api.notion.com/v1/blocks/{{ $json.pageId }}/children",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "notionApi",
          "sendHeaders": true,
          "specifyHeaders": "json",
          "jsonHeaders": "{\n  \"Notion-Version\": \"2022-06-28\"\n}",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ children: $json.blocks }) }}",
          "options": {}
        },
        "id": "append-page-content",
        "name": "Append Page Content",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          2420,
          -200
        ],
        "credentials": {
          "notionApi": {
            "id": "vGGxyUaNL70rqYcQ",
            "name": "Notion account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// No content to add, just pass through\nconst data = $('Build Page Blocks').item.json;\nreturn {\n  ...data.originalData,\n  page_content_added: false\n};"
        },
        "id": "skip-page-content",
        "name": "Skip Page Content",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2420,
          0
        ]
      },
      {
        "parameters": {
          "jsCode": "// Return original enriched data for response\nconst payload = $('Build Notion Payload').item.json;\nconst pageBlocks = $('Build Page Blocks').item.json;\n\nreturn {\n  ...payload.originalData,\n  notion_updated: true,\n  page_content_added: pageBlocks.hasContent,\n  notion_page_url: `https://notion.so/${payload.pageId.replace(/-/g, '')}`\n};"
        },
        "id": "merge-notion-result",
        "name": "Add Notion Status",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2640,
          -100
        ]
      },
      {
        "parameters": {
          "jsCode": "// No Notion page to update, just pass through\nconst data = $input.first().json;\nreturn {\n  ...data,\n  notion_updated: false\n};"
        },
        "id": "no-notion-update",
        "name": "Skip Notion Update",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1100,
          100
        ]
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ $json }}",
          "options": {}
        },
        "id": "respond-webhook",
        "name": "Respond to Webhook",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1.1,
        "position": [
          2860,
          0
        ]
      },
      {
        "parameters": {
          "method": "PATCH",
          "url": "=https://api.notion.com/v1/pages/{{ $('Detect URL Type').item.json.notionPageId }}",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "notionApi",
          "sendHeaders": true,
          "specifyHeaders": "json",
          "jsonHeaders": "{\n  \"Notion-Version\": \"2022-06-28\"\n}",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "{\n  \"properties\": {\n    \"Status\": { \"status\": { \"name\": \"Error\" } }\n  }\n}",
          "options": {}
        },
        "id": "set-error-status",
        "name": "Set Error Status",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          440,
          200
        ],
        "credentials": {
          "notionApi": {
            "id": "vGGxyUaNL70rqYcQ",
            "name": "Notion account"
          }
        }
      },
      {
        "parameters": {
          "method": "PATCH",
          "url": "=https://api.notion.com/v1/blocks/{{ $('Detect URL Type').item.json.notionPageId }}/children",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "notionApi",
          "sendHeaders": true,
          "specifyHeaders": "json",
          "jsonHeaders": "{\n  \"Notion-Version\": \"2022-06-28\"\n}",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ children: [{ object: 'block', type: 'callout', callout: { rich_text: [{ type: 'text', text: { content: 'Processing failed at ' + new Date().toISOString() + '. Error: ' + ($input.first().json.error?.message || 'Unknown error') } }], icon: { emoji: '‚ùå' }, color: 'red_background' } }] }) }}",
          "options": {}
        },
        "id": "add-error-to-page",
        "name": "Add Error to Page",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          660,
          200
        ],
        "credentials": {
          "notionApi": {
            "id": "vGGxyUaNL70rqYcQ",
            "name": "Notion account"
          }
        }
      },
      {
        "parameters": {
          "fromEmail": "notifications@royhen.app.n8n.cloud",
          "toEmail": "royhenengel@gmail.com",
          "subject": "=Bookmark Processing Failed: {{ $('Detect URL Type').item.json.url }}",
          "emailType": "text",
          "message": "=Bookmark processing failed.\n\nURL: {{ $('Detect URL Type').item.json.url }}\nDomain: {{ $('Detect URL Type').item.json.domain }}\nNotion Page ID: {{ $('Detect URL Type').item.json.notionPageId }}\n\nError: {{ $input.first().json.error?.message || 'Unknown error' }}\n\nTime: {{ new Date().toISOString() }}",
          "options": {
            "senderName": "LifeOS"
          }
        },
        "id": "send-error-email",
        "name": "Send Error Email",
        "type": "n8n-nodes-base.emailSend",
        "typeVersion": 2.1,
        "position": [
          880,
          200
        ]
      },
      {
        "parameters": {
          "jsCode": "// Return error response\nconst detectData = $('Detect URL Type').item.json;\nconst error = $input.first().json.error || { message: 'Unknown error' };\n\nreturn {\n  success: false,\n  url: detectData.url,\n  notionPageId: detectData.notionPageId,\n  error: error.message || error,\n  processed_at: new Date().toISOString()\n};"
        },
        "id": "build-error-response",
        "name": "Build Error Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1100,
          200
        ]
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ $json }}",
          "options": {
            "responseCode": 500
          }
        },
        "id": "respond-error",
        "name": "Respond with Error",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1.1,
        "position": [
          1320,
          200
        ]
      }
    ],
    "connections": {
      "Webhook": {
        "main": [
          [
            {
              "node": "Detect URL Type",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Detect URL Type": {
        "main": [
          [
            {
              "node": "Call Processor",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Call Processor": {
        "main": [
          [
            {
              "node": "Normalize Results",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Set Error Status",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Set Error Status": {
        "main": [
          [
            {
              "node": "Add Error to Page",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Add Error to Page": {
        "main": [
          [
            {
              "node": "Send Error Email",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Send Error Email": {
        "main": [
          [
            {
              "node": "Build Error Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Error Response": {
        "main": [
          [
            {
              "node": "Respond with Error",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Normalize Results": {
        "main": [
          [
            {
              "node": "Has Notion Page?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Has Notion Page?": {
        "main": [
          [
            {
              "node": "Build Notion Payload",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Skip Notion Update",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Notion Payload": {
        "main": [
          [
            {
              "node": "Update Notion Page",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Update Notion Page": {
        "main": [
          [
            {
              "node": "Get Page Blocks",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get Page Blocks": {
        "main": [
          [
            {
              "node": "Prepare Delete Blocks",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Delete Blocks": {
        "main": [
          [
            {
              "node": "Build Page Blocks",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Page Blocks": {
        "main": [
          [
            {
              "node": "Has Page Content?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Has Page Content?": {
        "main": [
          [
            {
              "node": "Append Page Content",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Skip Page Content",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Append Page Content": {
        "main": [
          [
            {
              "node": "Add Notion Status",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Skip Page Content": {
        "main": [
          [
            {
              "node": "Add Notion Status",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Skip Notion Update": {
        "main": [
          [
            {
              "node": "Respond to Webhook",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Add Notion Status": {
        "main": [
          [
            {
              "node": "Respond to Webhook",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Roy Hen Engel",
    "name": null,
    "description": null
  }
}
